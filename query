truncate table z_025_temp_ol
select * from z_025_temp_ol where id=42871763

delete from Z_025_TEMP_ol where s2 is null
create table Z_025_TEMP_RESULT

select utl_raw.cast_to_varchar2(s1) from Z_025_TEMP_ol

select sum(pb1)-sum(pb2) 
--pb1,pb2
from(
select p1,pb1,p2,pb2,
trim(C_PkgString.fToken2(s3,4,':()')) c1,
trim(C_PkgString.fToken2(s3,5,':()')) c2,
s2,s3
from
(select 
C_PkgString.fToken2(substr(s2,1,2000),1,';') p1,
C_PkgString.fToken2(substr(s2,1,2000),2,';') pb1,
C_PkgString.fToken2(substr(s2,1,2000),3,';') p2,
C_PkgString.fToken2(substr(s2,1,2000),4,';') pb2,
C_PkgString.fToken2(s3,3,';') r1,
s2,
s3
from
(select dbms_lob.substr(s1) s1,dbms_lob.substr(s2) s2,dbms_lob.substr(s3) s3 from Z_025_TEMP_ol)
)
where p1='П1' and p2='П2' and substr(pb1,1,1)<>'Ф' and substr(pb2,1,1)<>'Ф'
)
where
--(pb1<pb2 and c1>c2) or (pb1>pb2 and c1<c2)
(pb1<pb2 and c1<c2) or (pb1>pb2 and c1>c2)


call openconnection(user)
select to_number('12.25') from dual


  function fToken2(cStr        in varchar2,
                   iNum        in integer,
                   cDelimiters in varchar2 default '.,') return varchar2 as
    type tDelimitersPos is table of pls_integer index by binary_integer;
    dp   tDelimitersPos; -- список позиций разделителей
    iLen pls_integer := length(cStr);
    i    pls_integer := 1;
  begin
    dp(1) := 0;
    while i <= iLen loop
      if instr(cDelimiters, substr(cStr, i, 1)) > 0 then
        dp(dp.count + 1) := i;
        exit when dp.count > iNum; -- нашли обе границы "слова"
      end if;
      i := i + 1;
    end loop;
    if iNum < dp.count then
      i := dp(iNum);
      return substr(cStr, i + 1, dp(iNum + 1) - i - 1);
    elsif iNum = dp.count then
      return substr(cStr, dp(iNum) + 1);
    else
      return null;
    end if;
  end;

  function fToken(cStr        in varchar2,
                  iNum        in integer,
                  cDelimiters in varchar2 default '.,') return varchar2 as
    cTmp     varchar2(2000); -- буфер обработки
    iCounter pls_integer := 1; -- счетчик слов
    iPos     pls_integer := 1; -- позиция начала слова
    iSpace   pls_integer; -- позиция пробела
    iLen     pls_integer; -- длина строки
  begin
    cTmp := ltrim(translate(cStr, cDelimiters, '  '));
    iLen := length(cTmp);
    loop
      if iCounter > iNum then
        -- проскочили искомый номер
        return(null);
      elsif iCounter = iNum then
        -- слово ищем с первой позиции
        iSpace := instr(cTmp, ' ', iPos);
        if iSpace > 0 then
          -- слово выделено
          return(substr(cTmp, iPos, iSpace - iPos));
        else
          -- все что осталось и есть наше слово
          return(substr(cTmp, iPos));
        end if;
      else
        -- пока не дошли до нужного слова
        iSpace := instr(cTmp, ' ', iPos);
        if iSpace > 0 and iSpace < iLen then
          -- слово выделено
          iPos := iSpace + 1;
          while iPos <= iLen loop
            -- перебираем подряд пробелы до конца строки
            if substr(cTmp, iPos, 1) = ' ' then
              iPos := iPos + 1;
            else
              -- позиция первого символа следующего слова найдена
              exit;
            end if;
          end loop;
          if iPos > iLen then
            -- таки и не дошли
            return(null);
          end if;
        else
          -- только данное слово и осталось, но нам его не надо
          return(null);
        end if;
      end if;
      iCounter := iCounter + 1;
    end loop;
  end;

